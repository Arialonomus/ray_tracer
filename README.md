# Ray Tracer Challenge - Implementation

This repository contains a C++ implementation of the ray tracer spec outlined in _The Ray Tracer Challenge_ by Jamis Buck. Buck defines the specifications for the renderer using a test-driven approach, outlining program functionality as tests to make pass. I utilized Google Test for writing my test suites. 

The project is organized using a merged header and merged test philosophy, such that all related code files (headers, source, unit tests) are located in the same directory. src/ directory is organized related to program structure. The ray_tracer program itself is built from two statically linked libraries representing two layers of code. The first, the Graphics library (**gfx**), handles all lower level graphics computations and the associated code. **gfx** contains all data structures, geometry, and calculations related to shading and ray-object intersections. The second, higher layer, is the ray tracer program library (**rt**). **rt** handles functionality related to rendering images, and contains code for parsing scene data from JSON description (with help from nlohmann/json). **rt** interacts with **gfx** via the Camera which generates rays to be cast for processing by code in the **gfx** library.

Buck's architecture implicitly suggests an object-oriented approach, and--since I was coding in C++, I designed my implementation using classes. Generally, I tried to avoid mutable state in most of my objects--especially the core data structures. Some mutability did creep in in certain areas, but almost universally it was to facilitate testing the behavior of the object, and could easily be removed since no core functionality relied on it. I further strove to avoid deep inheritance hierarchies, though I utilized simple inheritence trees consisting of an abstract base class and concrete derived classes to define Surfaces and Patterns.

# Current Status

The project is fully functional, and implements the spec up through **Chapter 14 - Groups**, as well as a partial implementation of Bounding Boxes from the bonus content. Triangles are implemented, but I ultimately decided to finish the project here and move on to designing and writing my own ray tracer, taking the lessons I learned here and applying them towards a more extensible architecture. My thoughts on the project are below.

Overall I found the experience of implementing the Ray Tracer Challenge fairly enjoyable and easy to follow. I did, however, wrestle with the author's architectural decisions in the final sections of the book. Buck's design for a ray tracer is fairly simple, and well-suited to 3D geometric primitives (i.e. spheres, cubes, etc.). To accomplish this, the architecture couples the idea of a geometric primitive to that of a surface (which, if one is mostly working with spheres, cubes, etc. is a reasonable decision). He also generally avoids most of the intermediate-level data management concepts related to rendering, such as scene graphs and accelerators. Given the purpose of the book as teaching tool for basic ray tracing principles, this is again reasonable. However, as Buck adds triangle rendering, the architecture begins to show its cracks. 

I believe the primary issue is that the design does not have a solid abstraction for surfaces comprised of multiple primitives. Buck offers a Group class but it attempts to be too many things while also fitting poorly into the inheritance hierarchy for shapes that the book defines in earlier chapters. The Group class attempts to be a composite surface, while also doubling as something of a scene graph node, and (if you implement the bonus material) a BVH tree node. Buck's design has it inherit from the Surface class to allow it to function with our polymoprphic design for rendering different primitives. I found this strained the "is-a" heuristic beyond the breaking point and expanded the class hierarchy to have Groups and Surfaces function as sibling classes (treating Groups as CompositeSurfaces, to restrict their domain). This did not solve other issues, and required me to code a lot of unpleasant behavior to have child surfaces inherit materials from parent surfaces and handle transformations across parents and children. 

The design attempts to use the Group abstraction as a stand-in for a triangle mesh, but this requires treating each triangle as a surface (with its own transform and material). I attempted sketching out how to make more common approaches work within the architecture I had already implemented, but did not find a solution that would not require either significant reworking of the program structure or hacky solutions to handle triangle meshes. I felt I had learned enough by this point to start fresh and take my own approach to building a ray tracer, and so chose to finish up my implementation here, without proceeding through rendering triangle meshes.
